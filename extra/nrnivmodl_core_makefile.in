# This Makefile has the rules necessary for making the custom version of
# CoreNEURON executable called "special-core" from the provided mod files.
# Mod files are looked up in the MODS_PATH directory.

OUTPUT_DIR = @CMAKE_HOST_SYSTEM_PROCESSOR@

# Directory where cpp files are generated for each mod file
MOD_TO_CPP_DIR = $(OUTPUT_DIR)/corenrn/mod2c

# Directory where cpp files are compiled
MOD_OBJS_DIR = $(OUTPUT_DIR)/corenrn/build

# Find the directory of the current makefile
SELF_DIR := $(dir $(lastword $(MAKEFILE_LIST)))
include $(SELF_DIR)/GeneratedMakefile.make

# Current system OS
OS_NAME := $(shell uname)

# ","" is an argument separator, never as a literal for Makefile rule
COMMA_OP =,

# Default variables for various targets
MECHLIB_SUFFIX =
MODS_PATH = .
DESTDIR =
BUILD_TYPE = @COMPILE_LIBRARY_TYPE@

# CoreNEURON installation directories
CORENRN_BIN_DIR := $(ROOT)/bin
CORENRN_LIB_DIR := $(ROOT)/lib
CORENRN_INC_DIR := $(ROOT)/include
CORENRN_SHARE_CORENRN_DIR:= $(ROOT)/share/coreneuron
CORENRN_SHARE_MOD2CPP_DIR := $(ROOT)/share/mod2c

# file provided by coreneuron for solver
DERIVIMPLICIT_CPP_FILE = $(CORENRN_SHARE_CORENRN_DIR)/dimplic.cpp

# name of the CoreNEURON binary
SPECIAL_EXE  = $(OUTPUT_DIR)/special-core

# By default, build $(SPECIAL_EXE)
all: $(SPECIAL_EXE)

# Linked libraries gathered by CMake
LDFLAGS = $(LINKFLAGS) @CORENRN_LINK_DEFS@
CORENRNLIB_FLAGS = -L$(CORENRN_LIB_DIR) -lcoreneuron
CORENRNLIB_FLAGS += $(if @reportinglib_LIB_DIR@, -W$(subst ;, -W,l,-rpath,@reportinglib_LIB_DIR@),)
CORENRNLIB_FLAGS += $(if @sonatareport_LIB_DIR@, -W$(subst ;, -W,l,-rpath,@sonatareport_LIB_DIR@),)

# Includes paths gathered by CMake
INCLUDES = $(INCFLAGS) -I$(CORENRN_INC_DIR) -I$(CORENRN_INC_DIR)/coreneuron/utils/randoms
INCLUDES += $(if @MPI_C_INCLUDE_PATH@, -I$(subst ;, -I,@MPI_C_INCLUDE_PATH@),)
INCLUDES += $(if @reportinglib_INCLUDE_DIR@, -I$(subst ;, -I,@reportinglib_INCLUDE_DIR@),)

# C++ compilation and link commands
CXX = @CMAKE_CXX_COMPILER@
CXXFLAGS = @BUILD_TYPE_CXX_FLAGS@ @CMAKE_CXX_FLAGS@ @CXX14_STANDARD_COMPILE_OPTION@ @PGI_INLINE_FLAGS@
CXX_COMPILE_CMD = $(CXX) $(CXXFLAGS) @CMAKE_CXX_COMPILE_OPTIONS_PIC@ @CORENRN_COMPILE_DEFS@ $(INCLUDES)
CXX_LINK_EXE_CMD = $(CXX) $(CXXFLAGS) @CMAKE_EXE_LINKER_FLAGS@
CXX_SHARED_LIB_CMD = $(CXX) $(CXXFLAGS) @CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS@ @CMAKE_SHARED_LIBRARY_CXX_FLAGS@ @CMAKE_SHARED_LINKER_FLAGS@

# ISPC compilation and link commands
ISPC = @CMAKE_ISPC_COMPILER@
ISPC_COMPILE_CMD = $(ISPC) @CMAKE_ISPC_FLAGS@ -I$(CORENRN_INC_DIR)

# NMODL compiler
NMODL_COMPILER ?= $(ROOT)/bin/nmodl

# MOD2C compiler
MOD2C_COMPILER ?= @CORENRN_MOD2C_COMPILER@

# Binary of MOD2C/NMODL depending on CMake option activated
ifeq (@nmodl_FOUND@, TRUE)
    INCLUDES += -I@CORENRN_MOD2CPP_INCLUDE@
    ISPC_COMPILE_CMD += -I@CORENRN_MOD2CPP_INCLUDE@
endif

# env variables required for mod2c or nmodl
MOD2CPP_ENV_VAR = PYTHONPATH=@CORENRN_NMODL_PYTHONPATH@:${CORENRN_LIB_DIR}/python MODLUNIT=$(CORENRN_SHARE_MOD2CPP_DIR)/nrnunits.lib

# name of the mechanism library with suffix if provided
COREMECH_LIB_NAME = corenrnmech$(if $(MECHLIB_SUFFIX),_$(MECHLIB_SUFFIX),)
COREMECH_LIB_PATH = $(OUTPUT_DIR)/lib$(COREMECH_LIB_NAME)$(LIB_SUFFIX)

# Various header and C++/Object file
KINDERIV_H_PATH = $(MOD_TO_CPP_DIR)/_kinderiv.h
MOD_FUNC_CPP = $(MOD_TO_CPP_DIR)/_mod_func.cpp
MOD_FUNC_OBJ = $(MOD_OBJS_DIR)/_mod_func.o
DIMPLIC_CPP  = $(MOD_TO_CPP_DIR)/_dimplic.cpp
DIMPLIC_OBJ  = $(MOD_OBJS_DIR)/_dimplic.o
ENGINEMECH_OBJ = $(MOD_OBJS_DIR)/enginemech.o

# Depending on static/shared build, determine library name and it's suffix
ifeq ($(BUILD_TYPE), STATIC)
    LIB_SUFFIX = @CMAKE_STATIC_LIBRARY_SUFFIX@
    corenrnmech_lib_target = coremech_lib_static
else
    LIB_SUFFIX = @CMAKE_SHARED_LIBRARY_SUFFIX@
    corenrnmech_lib_target = coremech_lib_shared
endif

# We use $ORIGIN (@loader_path in OSX)
ORIGIN_RPATH := $(if $(filter Darwin,$(OS_NAME)),@loader_path,$$ORIGIN)
SONAME_OPTION := -Wl,$(if $(filter Darwin,$(OS_NAME)),-install_name${COMMA_OP}@rpath/,-soname${COMMA_OP})$(notdir ${COREMECH_LIB_PATH})
LIB_RPATH = $(if $(DESTDIR),$(DESTDIR)/lib,$(ORIGIN_RPATH))

# All objects used during build
ALL_OBJS = $(MOD_FUNC_OBJ) $(DIMPLIC_OBJ) $(PRODUCED_OBJS_FROM_CPP) $(PRODUCED_OBJS_FROM_ISPC)

# Colors for pretty printing
C_RESET := \033[0m
C_GREEN := \033[32m

# Default nmodl flags. Override if MOD2CPP_RUNTIME_FLAGS is not empty
NMODL_FLAGS_ISPC = $(if $(MOD2CPP_RUNTIME_FLAGS),$(MOD2CPP_RUNTIME_FLAGS),@nmodl_arguments_ispc@)
MOD2CPP_FLAGS_C = $(if $(MOD2CPP_RUNTIME_FLAGS),$(MOD2CPP_RUNTIME_FLAGS),@nmodl_arguments_c@)
ifeq (@CORENRN_ENABLE_ISPC@, ON)
    $(info Default nmodl flags: @nmodl_arguments_ispc@)
else
    $(info Default nmodl flags: @nmodl_arguments_c@)
endif
ifneq ($(MOD2CPP_RUNTIME_FLAGS),)
    $(warning Runtime nmodl flags (they replace the default ones): $(MOD2CPP_RUNTIME_FLAGS))
endif

# ======== MAIN BUILD RULES ============


# main target to build binary
$(SPECIAL_EXE): coremech_lib_target
	@printf " => $(C_GREEN)Binary$(C_RESET) creating $(SPECIAL_EXE)\n"
	$(CXX_LINK_EXE_CMD) -o $(SPECIAL_EXE) $(CORENRN_SHARE_CORENRN_DIR)/coreneuron.cpp \
	  -I$(CORENRN_INC_DIR) $(INCFLAGS) \
	  -L$(OUTPUT_DIR) -l$(COREMECH_LIB_NAME) $(CORENRNLIB_FLAGS) $(LDFLAGS) \
	  -Wl,-rpath,'$(LIB_RPATH)' -Wl,-rpath,$(CORENRN_LIB_DIR)

coremech_lib_target: $(corenrnmech_lib_target)
	rm -rf $(OUTPUT_DIR)/.libs; \
	mkdir -p $(OUTPUT_DIR)/.libs; \
	ln -s ${COREMECH_LIB_PATH} $(OUTPUT_DIR)/.libs/libcorenrnmech$(LIB_SUFFIX)

$(ENGINEMECH_OBJ): | $(MOD_OBJS_DIR)
	$(CXX_COMPILE_CMD) -c -DADDITIONAL_MECHS $(CORENRN_SHARE_CORENRN_DIR)/enginemech.cpp -o $(ENGINEMECH_OBJ)

# build shared library of mechanisms
coremech_lib_shared: $(ALL_OBJS) $(ENGINEMECH_OBJ) build_always
	$(CXX_SHARED_LIB_CMD) $(ENGINEMECH_OBJ) -o ${COREMECH_LIB_PATH} $(ALL_OBJS) \
	  -I$(CORENRN_INC_DIR) $(INCFLAGS) \
	  $(LDFLAGS) $(CORENRN_LIB_DIR)/libscopmath.a \
	  ${SONAME_OPTION} $(CORENRNLIB_FLAGS) -Wl,-rpath,$(CORENRN_LIB_DIR);

# build static library of mechanisms
coremech_lib_static: $(ALL_OBJS) $(ENGINEMECH_OBJ) build_always
	mkdir -p $(MOD_OBJS_DIR)/scopmath; \
	cd $(MOD_OBJS_DIR)/scopmath && ar -x $(CORENRN_LIB_DIR)/libscopmath.a && cd -;\
	rm -f ${COREMECH_LIB_PATH}; \
	ar cq ${COREMECH_LIB_PATH} $(ENGINEMECH_OBJ) $(ALL_OBJS) $(MOD_OBJS_DIR)/scopmath/*.o;

# generate mod registration function. Dont overwrite if it's not changed
$(MOD_FUNC_CPP): build_always | $(MOD_TO_CPP_DIR)
	@PERL_EXECUTABLE@ $(CORENRN_SHARE_CORENRN_DIR)/mod_func.c.pl $(MOD_FILES) > $(MOD_FUNC_CPP).tmp
	diff -q $(MOD_FUNC_CPP).tmp $(MOD_FUNC_CPP) || \
	mv $(MOD_FUNC_CPP).tmp $(MOD_FUNC_CPP)

$(MOD_FUNC_OBJ) $(DIMPLIC_OBJ): $(MOD_OBJS_DIR)/%.o: $(MOD_TO_CPP_DIR)/%.cpp $(KINDERIV_H_PATH) | $(MOD_OBJS_DIR)
	$(CXX_COMPILE_CMD) -c $< -o $@

# header to avoid function callbacks using function pointers
$(KINDERIV_H_PATH): $(mod_cpp_files) build_always | $(MOD_TO_CPP_DIR)
	cd $(MOD_TO_CPP_DIR); \
	@PYTHON_EXECUTABLE@ $(CORENRN_SHARE_CORENRN_DIR)/kinderiv.py;

# symlink to cpp files provided by coreneuron
$(MOD_TO_CPP_DIR)/%.cpp: $(CORENRN_SHARE_MOD2CPP_DIR)/%.cpp | $(MOD_TO_CPP_DIR)
	ln -s $< $@

# to recompile dimplic.cpp for solvers
$(DIMPLIC_CPP): $(DERIVIMPLICIT_CPP_FILE) | $(MOD_TO_CPP_DIR)
	ln -s $(DERIVIMPLICIT_CPP_FILE) $(DIMPLIC_CPP)

# create directories needed
$(MOD_TO_CPP_DIR):
	mkdir -p $(MOD_TO_CPP_DIR)

$(MOD_OBJS_DIR):
	mkdir -p $(MOD_OBJS_DIR)

# install binary and libraries
install: $(SPECIAL_EXE) coremech_lib_target
	install -d $(DESTDIR)/bin $(DESTDIR)/lib
	install ${COREMECH_LIB_PATH} $(DESTDIR)/lib
	install $(SPECIAL_EXE) $(DESTDIR)/bin

.PHONY: build_always

$(VERBOSE).SILENT:

# delete cpp files if mod2c error, otherwise they are not generated again
.DELETE_ON_ERROR:
